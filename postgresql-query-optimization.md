# Обработка SQL запроса на стороне СУБД
* разбор SQL в логический план (_**logical plan**_)
* оптимизация логического плана и преобразование в план исполнения (**_execute plan_**)
* выполнение и получение результатов

# Алгоритмы доступа к данным
* ### Full Scan
  * выбираем, когда возвращаем много данных
* ### Index-Based Table Access
  * когда нужно получить не более 5% данных из таблицы
* **_Index-Only Scan_** - когда нужно вернуть только столбцы, которые есть в индексе и нет смысла обращаться к таблице

# Индексы
* индекс - отдельная структура данных, связанная с таблицей
* ### B-Tree index
  * более быстрое обновление при модификации данных в таблице
  * поиск за **Log(n)/Log(f),** где f - количество указателей в одном блоке
  * может быть создан для порядковых типов
  * **поддерживает операции поиска по диапазону**
* ### Hash index
  * используется хэш значения в качестве ключа
  * _**отлично подходит для операций строгого сравнения**_
  * НО НЕ подходит для для поиска по диапазону
* ### R-Tree index
  * структура схожа с B-Tree, но хранит индексацию по пространственным данным. В частности используется для **поиска 
    по координатам**

# Алогритмы для соединения таблиц

* ### nested loop
  * cost = size(A) * size(B)
  * хорошо для небольших выборок данных
* ### hash join
  * работает через промежуточную хэш-таблицу: раскидывает значения из первой и второй таблицы по бакетам, использую 
    хэш-функцию. Затем ищет бакеты, в которые попали записи из обоих таблиц
  * cost = size(A) + size(B) + size(A)*size(B)/size(JA), где JA - join attribute
* ### sort-merge join
  * предварительно сортируем обе таблицы
  * двигаемся одновременно по обоим таблицам, отбирая совпадающие строки. За счёт сортировки, достаточно одного 
    прохода по обеим таблицам
  * const = size(A)*log(size(A)) + size(B)*log(size(B))
